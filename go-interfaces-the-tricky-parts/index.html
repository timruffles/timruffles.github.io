<!doctype html>
      <head>
        <title>Go interfaces, the tricky parts</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta name="viewport" content="width=device-width">
        <meta name="description" content="%0A" >
        <link rel="stylesheet" href="/css/normalize.css" type="text/css">
        <link rel="stylesheet" href="/css/style.css" type="text/css">
        <link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-24335480-1']);
          _gaq.push(['_trackPageview']);

          function asyncScript(src) {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = src;
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          }
          asyncScript(('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js');
        </script>
        <link rel="alternate" type="application/rss+xml" title="Subscribe to RSS feed" href="/rss.xml" />
      </head>
      <body class="article">
        <div id="mast">
          <div class='top-bar reading'>
              <div class="links logical">
                <div class="navigation logical">
                  <a href="/">Home</a>
                  <a href="/rss.xml">RSS</a>
                  <a href="/me">
                      Tim Ruffles
                  </a>
                </div>
              </div>
            </div>
        </div>
        <div id="content" class="reading">
           

           <div id="body">
              <h1><a href="/go-interfaces-the-tricky-parts">Go interfaces, the tricky parts</a></h1>
  <p>Does this Go snippet compile, and if not, why?</p>
<pre><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  users <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>User<span class="token punctuation">{</span>User<span class="token punctuation">{</span><span class="token string">"alice"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span><span class="token string">"bob"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>

  <span class="token comment">// hint: this line compiles, User fulfils Named</span>
  <span class="token keyword">var</span> <span class="token boolean">_</span> Named <span class="token operator">=</span> User<span class="token punctuation">{</span><span class="token string">"charlie"</span><span class="token punctuation">}</span>

  <span class="token function">getName</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token function">getNames</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">getName</span><span class="token punctuation">(</span>n Named<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span> n<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">getNames</span><span class="token punctuation">(</span>ns <span class="token punctuation">[</span><span class="token punctuation">]</span>Named<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span></code></pre>
<p>It doesn&#39;t compile. Surprisingly, although <code>User</code> implements <code>Named</code>, and the <code>getName</code> call is fine, the <code>getNames(users)</code> call is a type error.</p>
<p>When I first came to Go, I found it confusing that, given (1) <code>User</code> implemented <code>Named</code>, and (2) <code>getName(someUser)</code> compiled, that:</p>
<ul>
<li>I couldn&#39;t pass <code>[]User</code> as a <code>[]Named</code></li>
<li>I couldn&#39;t pass <code>[]User</code> as an <code>[]interface{}</code></li>
<li>I couldn&#39;t pass <code>*User</code> as <code>*Named</code></li>
</ul>
<p>
</p><details>
  <summary>Here's a fuller example demonstrating all of these cases.</summary>

</details><p>  <code></code><pre></pre>
  package main
  import "fmt"
  func main() {
    users := []User{User{"alice"}, User{"bob"}}</p>
<pre><code><span class="token function">getName</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// cannot use users (type []User) as type []Named in </span>
<span class="token comment">// argument to getNames</span>
<span class="token function">getNames</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span>
<span class="token comment">// cannot use users (type []User) as type []interface </span>
<span class="token comment">// {} in argument to countSlice</span>
<span class="token function">countSlice</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span>
<span class="token comment">// cannot (type *User) as type *Named in argument </span>
<span class="token comment">// to switchNamed:</span>
<span class="token function">switchNamed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>users<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>users<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
<p>  }</p>
<p>  func getName(n Named) string { 
     return n.name() 
  }
  func getNames(ns []Named) []string    { /* ... */ }
  func countSlice(ns []interface{}) int {
    return len(ns) 
  }
  func switchNamed(a,b <em>Named) { /</em> ... */ }</p>
<p>  type User struct {
    fullName string
  }
  func (u User) name() string { return u.fullName }</p>
<p>  type Named interface {
    name() string
  }
  </p>
<p><a href="https://play.golang.org/p/TXe-4OTwNho">Runnable code</a></p>

<p></p>

<h2 id="why-cant-go-be-like-language">Why can&#39;t Go be like <code>$language</code>?</h2>
<p>It felt inconsistent. It was also very different from languages like TypeScript and Java, where if <code>User</code> implemented <code>Named</code>, as well as being able to pass <code>User</code> to a method accepting <code>Named</code>:</p>
<ul>
<li>I could pass <code>User[]</code> as a <code>Named[]</code></li>
<li>I could pass <code>User[]</code> as an <code>any[]</code> (TypeScript only)</li>
</ul>
<p>For instance, here&#39;s the same example in TypeScript (minus <code>switchNamed</code> as TS doesn&#39;t have pointers) which compiles and runs without a hitch:</p>
<pre><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"alice"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"bob"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
      <span class="token function">getName</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"charlie"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">getNames</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">countArray</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> fullName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fullName <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
  <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span>n<span class="token operator">:</span> Named<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">getNames</span><span class="token punctuation">(</span>ns<span class="token operator">:</span> Named<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ns<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">=></span> n<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">countArray</span><span class="token punctuation">(</span>ns<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ns<span class="token punctuation">.</span>length <span class="token punctuation">}</span></code></pre>
<p>The mystery I wanted to solve was why Go worked exactly the same way in some places (<code>getName(users[0])</code>), but not in others (<code>getNames</code> and <code>countSlice</code>). To solve it I had to learn how Go&#39;s interfaces really worked.</p>
<h2 id="clearing-up-the-mystery">Clearing up the mystery</h2>
<p>First, an intuition for the difference between interface values and concrete values in Go. Imaging helping your friend move their pets to a new home. They give you two boxes, one  labelled &#39;friendly snakes&#39;, one &#39;fluffy spiders&#39;. Easy enough, sling both boxes in your car and drive! But does that scenario prove you could do the same if they just handed you the critters unboxed? Not at all.</p>
<p>Equivalently, do not assume that because you can store a concrete <code>User</code> <strong>in</strong> a <code>Named</code> interface value, you can use that concrete value <strong>as</strong> an interface value. A concrete value and an interface value containing it are fundamentally different things and can be used in different ways.</p>
<p>But if that&#39;s true, how is <code>logOne</code> able to accept <code>User</code> values? Simple: the Go compiler automatically creates interface values for you where it can. The two lines below are equivalent:</p>
<pre><code class="language-go"><span class="token comment">// Go implicitly allocates an interface value and places the User in it</span>
<span class="token function">logOne</span><span class="token punctuation">(</span>User<span class="token punctuation">{</span><span class="token string">"charlie"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// ...equivalent to us manually allocating one and passing it</span>
<span class="token keyword">var</span> f1 Named <span class="token operator">=</span> User<span class="token punctuation">{</span><span class="token string">"charlie"</span><span class="token punctuation">}</span>
<span class="token function">logOne</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span></code></pre>
<h2 id="what-interface-values-are-really">What interface values are really</h2>
<p>Let&#39;s make it concrete by considering what these &#39;boxes&#39; look like. Go&#39;s interface values are really a <a href="https://www.tapirgames.com/blog/golang-interface-implementation" >pair of pointers</a>. When you put a concrete value into an interface value, one pointer starts pointing at the value. The second will now point to the implementation of the interface for the type of the concrete value. They&#39;re called the dynamic value and the dynamic type respectively - dynamic because both are set at runtime when we assign concrete values into an interface value.</p>
<img alt="Go interface value" src="/img/go-interface-values.JPG" width="328">

<p>This pair of pointers is the secret to how Go&#39;s interfaces work. When a method is called on an interface value, Go follows the implementation pointer to find the appropriate method and the value pointer to be able to use the value as the receiver (or it panics if the &#39;box&#39; is empty: a nil value). Thus you can see why code that works with an interface value really cannot work on concrete values alone.</p>
<h2 id="the-slice-inconsistency">The slice inconsistency</h2>
<p>A check on your understanding: why can&#39;t we pass a <code>[]User</code> as a <code>[]Named</code>? Try to think through what the two slices/backing arrays would look like in memory.</p>
<details>
  <summary>Answer</summary>

</details><p>The crux is again that an interface value is a different thing to a concrete value, rather than - as in other languages - just another way a concrete value can be used. Each cell in a slice of interface values will contain one of those familiar double pointer values:</p>

<p><img width="328" src="/img/go-interface-slices.JPG" alt="Go interface slice vs value slice"></p>

<p>However, given Go can automatically allocate a <code>Named</code> where required, couldn&#39;t Go also allocate a <code>[]Named</code> automatically to let you pass a <code>[]User</code> to <code>getNames</code>? It&#39;s certainly possible to imagine how Go could do it. It could allocate a new slice of interface values for you, and assign the concrete <code>User</code> values into corresponding indexes:</p>
<pre><code class="language-go">users <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>User<span class="token punctuation">{</span>User<span class="token punctuation">{</span><span class="token string">"alice"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span><span class="token string">"bob"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token comment">// below is what Go would have to do to make switchItems(users, 0, 1) work implicitly</span>
ns <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Named<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> users <span class="token punctuation">{</span>
  <span class="token keyword">var</span> n Named <span class="token operator">=</span> u
  ns <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token comment">// *</span>
<span class="token punctuation">}</span>

<span class="token function">getNames</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span></code></pre>
<p>Indeed, for <code>getNames(users)</code> this would actually work fine! But slices have mutable indexes. and many functions mutate the slices they&#39;re passed. Can you see why automatically creating new slices to pass in would not work as desired for such functions? For instance:</p>
<pre><code class="language-go"><span class="token keyword">func</span> <span class="token function">switchItems</span><span class="token punctuation">(</span>xs <span class="token punctuation">[</span><span class="token punctuation">]</span>Named<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  t <span class="token operator">:=</span> xs<span class="token punctuation">[</span>a<span class="token punctuation">]</span>
  xs<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> xs<span class="token punctuation">[</span>b<span class="token punctuation">]</span>
  xs<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> t
<span class="token punctuation">}</span>

users <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>User<span class="token punctuation">{</span>User<span class="token punctuation">{</span><span class="token string">"alice"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span><span class="token string">"bob"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token comment">// not possible, but imagine it was and Go did the implicit </span>
<span class="token comment">// allocate/initialize we did above</span>
<span class="token function">switchItems</span><span class="token punctuation">(</span>users<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre>
<p>The implicit allocation would stop <code>switchItems</code> from working as we&#39;d only be affecting the newly allocated slice/backing array - <code>ns</code> in the example above where I showed you what Go would have to do to make it work.</p>
<p>Again, Go&#39;s helpful implicit conversions can make this confusing - for <code>append(ns, n)</code> we could just do <code>append(ns, u)</code>, but now we know Go must be allocating the interface value for us.</p>
<h2 id="takeaways">Takeaways</h2>
<p>If get a type error when you attempt to use a concrete value in a place needing an interface value and you think &quot;but it fulfils the interface&quot;, remember: interface values and concretes are very different things. That you can place a concrete value in an interface value does not mean it is an interface value, so you can&#39;t use it in all the same ways.</p>
<p>For instance, if you have a function accepting <code> []interface{}</code> you can&#39;t pass a slice of concrete values. Although we know all interfaces fulfil the empty interface, an interface value is still different from a concrete value: it&#39;s a container which allows us to peek in and extract the concrete type via type assertions. So if we have a slice of concrete values we&#39;re going to have to allocate interface values to pass in:</p>
<pre><code class="language-go"><span class="token keyword">func</span> <span class="token function">findAndRemoveUsers</span><span class="token punctuation">(</span>xs <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> i<span class="token punctuation">,</span> x <span class="token operator">:=</span> <span class="token keyword">range</span> xs <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> x<span class="token punctuation">.</span><span class="token punctuation">(</span>User<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"There is a user at"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
      xs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

users <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>User<span class="token punctuation">{</span>User<span class="token punctuation">{</span><span class="token string">"alice"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span><span class="token string">"charlie"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>

<span class="token comment">// could just as well be []interface{}</span>
ivs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Named<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> users <span class="token punctuation">{</span>
  ivs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ivs<span class="token punctuation">,</span> u<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">findAndRemoveUsers</span><span class="token punctuation">(</span>ivs<span class="token punctuation">)</span>

<span class="token comment">// double check it's clear to you why this couldn't be </span>
<span class="token comment">// supported automatically - consider xs[i] = nil </span>
<span class="token function">findAndRemoveUsers</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span></code></pre>
<h2 id="quiz-time">Quiz time</h2>
<p>Why couldn&#39;t Go do something clever to let us pass a pointer to a <code>User</code> to a method accepting a pointer to <code>Named</code>?</p>
<pre><code class="language-go"><span class="token keyword">func</span> <span class="token function">switchNamed</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b <span class="token operator">*</span>Named<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  t <span class="token operator">:=</span> <span class="token operator">*</span>a
  <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b
  <span class="token operator">*</span>b <span class="token operator">=</span> t
<span class="token punctuation">}</span>

u1 <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"denise"</span><span class="token punctuation">}</span>
<span class="token comment">// type error</span>
<span class="token function">switchNamed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>u1<span class="token punctuation">)</span></code></pre>
<details>
  <summary>Spoiler</summary>

</details><p>Much like with the slice example above, <code>switchNamed(&amp;u1)</code> to work Go would have to automatically allocate an interface value. If it did, and passed that into the function, assignments to that fresh <code></code>*Named would have no affect on the original <code></code>*User, and so no visibility outside the function. So instead it&#39;s a compile-time type error:</p>
<pre>// this compiles fine
var f1 Named = User{"alice"}
var f2 Named = User{"bob"}
fmt.Println(f1, f2) // {"alice", "bob"}
switchNamed(&amp;f1, &amp;f2)
fmt.Println(f1, f2) // {"bob", "alice"}

u1 := User{"charlie"}
u2 := User{"denise"}
fmt.Println(u1, u2) // {"charlie", "denise"}

// this won't compile - 'can't use type *User as *Named'
// switchNamed(&amp;u1, &amp;u2)

// because if we implicitly generated new *Named values
// for the &amp;u1, &amp;u2 passed to the method...
var n1 Named = u1
var n2 Named = u2
switchNamed(&amp;n1, &amp;n2)
// ....we'd end up with u1 and u2 unaffected!
fmt.Println(u1, u2) // {"charlie", "denise"}

</pre>

<p>Note: pointers to interfaces are fairly rare in practise.</p>
<p>Thanks to <a href="https://mobile.twitter.com/camsmorgan">Campbell Morgan</a>, <a href="https://iheanyi.com/">Iheanyi Ekechukwu</a> and <a href="https://bradshaw.io/">Stephen Bradshaw</a> for reviewing this and offering their wisdom!</p>

  
            </div>
        </div>
        <div class="footer reading">
          <div class="container">
            <p>ðŸ“© helloï¼ timr Â· co</p>
          </div>
        </div>
      </body>